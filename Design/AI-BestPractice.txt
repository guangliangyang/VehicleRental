best practice for using AI assistants in programming. 

1. Warm up the AI ​​assistant; it should be familiar with my project structure, coding style, unit tests, and CI/CD. 

2. Start by creating a new branch for each new feature. 

3. Detail the use case for the new feature. The AI" ​​should help clarify the requirements, including inputs, outputs, 
    exceptions, edge cases, and so on, give me a entire  user case baseon my project
  infrasturecture, and save to design/userCase1.md, i will ask other expert to find a best practice solution. ", 
  and discuss them with developers until they confirm. 
    
4. Query different AI platforms (ChatGPT, Claude, Grok, Gemni) to find the best practices for this requirement 
" give me a best practice in 200 words"
    and weigh their pros and cons. Ultimately, 
    " is any cons?"
    paste response from other AI advice.

    "make a comprehensive solution and save the detailed plan as a blueprint for the future.  and store in design"
    
5. Instruct the AI ​​assistant to break the solution into small steps, 
    each of which can be reviewed and verified as quickly as possible. 
    Save these steps as an execution plan, 
    driven by the solution blueprint to make the context as clear as possible. 

6. Start executing each small step. 
    The prompt should be: The blueprint and plan can be find in Design. Use the UTT principle to implement the code. 
    Remember to align the code style, 
    UTT reqrier that Coverage ≥ 80%, Include positive, negative, and abnormal inputs ,Do not rely on external state or real services;
    delete duplicate code and functions, do not add extra features, functions or documents, 
    delete obsolete functions or classes or configurations and documents. 
    
    After AI generates the code, run UT, code linters, and verify whether this step is completed. 
    and update the plan file, set the sub step is fininshed.

7. When all small steps are completed, 
    align the code style, delete duplicate code and functions, do not add extra features, functions or documents, 
    delete obsolete functions or classes or configurations and documents, run UT, code linters, 
    and verify whether this use case is completed and where there is room for improvement. 
    Give the developer a conclusion. 
    
8. The developer confirms and pushes the branch to git

9.  code specification
    1. Clean Architecture                                                                              │ │
│ │ 2. Domain-Driven Design                                                                                       │ │
│ │ 3. Result Pattern Usage: Proper error handling without exceptions                                                                                         │ │
│ │ 4. SOLID Principles: Following dependency inversion and single responsibility                                                                             │ │
│ │ 5. Testing Strategy: Writing appropriate unit tests for new functionality

 